//
//  GamePresenter.swift
//  Snake
//
//  Created by Zvonimir Medak on 21.02.2022..
//  Copyright (c) 2022 ___ORGANIZATIONNAME___. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import Foundation
import ARKit
import Combine
import CombineExt

final class GamePresenter {

    // MARK: - Private properties -

    private unowned let view: GameViewInterface
    private let interactor: GameInteractorInterface
    private let wireframe: GameWireframeInterface

    private var cancellables: Set<AnyCancellable> = []

    // MARK: - Lifecycle -

    init(
        view: GameViewInterface,
        interactor: GameInteractorInterface,
        wireframe: GameWireframeInterface
    ) {
        self.view = view
        self.interactor = interactor
        self.wireframe = wireframe
    }
}

// MARK: - Extensions -

extension GamePresenter: GamePresenterInterface {

    func configure(with output: Game.ViewOutput) -> Game.ViewInput {
        let foodNodeRelay = PassthroughRelay<FoodNode?>()
        let gameOverRelay = PassthroughRelay<Void>()
        let userActionRelay = PassthroughRelay<UserForm.Action>()
        let scoreRelay = CurrentValueRelay<Float>(0)
        let gameStartedRelay = PassthroughRelay<Void>()

        let arenaNode = handle(willRenderScene: output.willRenderScene, startGameAction: gameStartedRelay.asSignal())
        let countdownNode = handle(
            startGameAction: output.startGame,
            arenaNode: arenaNode,
            gameStartedRelay: gameStartedRelay
        )

        handle(snakeTurningAction: output.snakeTurningAction)
        handle(didBeginContact: output.contactAction, foodNodeRelay: foodNodeRelay, gameOverRelay: gameOverRelay)
        handle(gameOverAction: gameOverRelay.asSignal(), score: scoreRelay.asDriver(), userActionRelay: userActionRelay)
        handle(userActionRelay: userActionRelay.asSignal())
        handle(foodNodeAction: foodNodeRelay.asSignal(), scoreRelay: scoreRelay)
        handle(score: scoreRelay.asDriver())
        handleSnakeMovement()

        return Game.ViewInput(
            arenaSetup: Publishers.Merge(arenaNode, countdownNode).asDriver()
        )
    }
}

// MARK: - Handlers

private extension GamePresenter {

    func handle(willRenderScene: Signal<ARHitTestResult?>, startGameAction: Signal<Void>) -> Driver<SCNNode?> {
        let arenaNodeBuilder: (ARHitTestResult?) -> SCNNode? = { [unowned self] hitResult in
            guard let hitResult = hitResult else { return nil }
            let position = hitResult.worldTransform.columns.3
            return interactor.makeArena(with: SCNVector3(position.x, position.y, position.z), isStart: true, time: nil)
        }
        return willRenderScene
            .prefix(untilOutputFrom: startGameAction)
            .map(arenaNodeBuilder)
            .asDriver()
    }

    func handle(
        startGameAction: Signal<Void>,
        arenaNode: Driver<SCNNode?>,
        gameStartedRelay: PassthroughRelay<Void>
    ) -> Driver<SCNNode?> {
        let timer = makeStartGameTimer()

        let arenaCountdownBuilder: (Int, SCNNode) -> SCNNode = { [unowned self] time, arenaNode in
            guard time > 0 else {
                return interactor.makeGameStartedNode(using: arenaNode.position)
            }
            return interactor.makeArena(with: arenaNode.position, isStart: false, time: time)
        }

        return startGameAction
            .prefix(untilOutputFrom: gameStartedRelay)
            .map(to: timer)
            .switchToLatest()
            .withLatestFrom(arenaNode.compactMap { ($0) }) { ($0, $1) }
            .handleEvents(receiveOutput: { _ in gameStartedRelay.accept(()) })
            .map(arenaCountdownBuilder)
            .asDriver()
    }

    func handle(
        didBeginContact: Signal<SCNPhysicsContact>,
        foodNodeRelay: PassthroughRelay<FoodNode?>,
        gameOverRelay: PassthroughRelay<Void>
    ) {
        didBeginContact
            .removeDuplicates()
            .throttle(for: .seconds(0.1), scheduler: RunLoop.main, latest: false)
            .sink(receiveValue: { [unowned self] in handle(contact: $0, foodNodeRelay: foodNodeRelay, gameOverRelay: gameOverRelay) })
            .store(in: &cancellables)
    }

    func handle(
        contact: SCNPhysicsContact,
        foodNodeRelay: PassthroughRelay<FoodNode?>,
        gameOverRelay: PassthroughRelay<Void>
    ){
        if handle(didSnakeMakeContactWithFoodUsing: contact) {
            handle(snakeCollectedFoodUsing: foodNodeRelay)
        } else if handle(didSnakeMakeContactWithBodyUsing: contact) || handle(didSnakeMakeContactWithArenaUsing: contact) {
            handle(gameOverUsing: gameOverRelay)
        }
    }

    func handle(gameOverAction: Signal<Void>, score: Driver<Float>, userActionRelay: PassthroughRelay<UserForm.Action>) {
        gameOverAction
            .withLatestFrom(score)
            .handleEvents(receiveOutput: { [unowned interactor] _ in interactor.currentArenaNode?.removeFromParentNode() })
            .sink(receiveValue: { [unowned self] in wireframe.navigateToUserForm(score: $0, userActionRelay: userActionRelay) })
            .store(in: &cancellables)
    }

    func handle(userActionRelay: Signal<UserForm.Action>) {
        let navigationHandler: (UserForm.Action) -> Void = { [unowned wireframe] action in
            switch action {
            case .done:
                wireframe.navigateToHighscores()
            case .skip:
                wireframe.navigateToHome()
            }
        }
        userActionRelay
            .sink(receiveValue: navigationHandler)
            .store(in: &cancellables)
    }
    
    func handle(snakeTurningAction: Signal<SnakeTurning>) {
        let turnDirectionBuilder: (SnakeTurning) -> DirectionManager.TurnDirection? = { [unowned interactor] movement in
            guard let snakeDirection = interactor.snakeNode?.snake.moveDirection else { return nil }
            return DirectionManager.turnDirection(using: (movement.pointOfView.x, movement.pointOfView.z), snakeDirection: snakeDirection, swipeDirection: movement.swipeDirection)
        }
        let snakeTurningHandler: (DirectionManager.TurnDirection) -> Void = { [unowned interactor] turnDirection in
            switch turnDirection {
            case .right:
                interactor.snakeNode?.turnRight()
            case .left:
                interactor.snakeNode?.turnLeft()
            }
        }
        return snakeTurningAction
            .compactMap(turnDirectionBuilder)
            .sink(receiveValue: snakeTurningHandler)
            .store(in: &cancellables)
    }

    func handleSnakeMovement() {
        let tickInterval = interactor.gameSpeedUpdateInterval
        Timer
            .publish(every: .init(tickInterval), on: .main, in: .common)
            .autoconnect()
            .compactMap { [unowned interactor] _ in interactor.snakeNode }
            .sink(receiveValue: { $0.move() })
            .store(in: &cancellables)
    }

    func handle(foodNodeAction: Signal<FoodNode?>, scoreRelay: CurrentValueRelay<Float>) {
        foodNodeAction
            .compactMap { $0 }
            .withLatestFrom(scoreRelay) { ($0, $1) }
            .handleEvents(receiveOutput: { [unowned interactor] in scoreRelay.accept(interactor.calculateNewScore(with: $0.1)) })
            .map(\.0)
            .map { [unowned interactor] in ($0, interactor.currentArenaNode) }
            .sink(receiveValue: { $1?.addChildNode($0) })
            .store(in: &cancellables)
    }

    func handle(score: Driver<Float>) {
        score
            .sink(receiveValue: { [unowned interactor] in interactor.updateScoreNode(currentScore: $0) })
            .store(in: &cancellables)
    }
    
    func handle(snakeCollectedFoodUsing foodNodeRelay: PassthroughRelay<FoodNode?>){
        interactor.foodNode?.removeFromParentNode()
        interactor.snakeNode?.grow()
        foodNodeRelay.accept(interactor.makeFoodNode())
    }
    
    func handle(gameOverUsing gameOverRelay: PassthroughRelay<Void>){
        gameOverRelay.accept(())
    }

    func handle(didSnakeMakeContactWithFoodUsing contact: SCNPhysicsContact) -> Bool {
        return contact.nodeA.physicsBody?.categoryBitMask == ContactCategory.food.rawValue
            || contact.nodeB.physicsBody?.categoryBitMask == ContactCategory.food.rawValue
    }

    func handle(didSnakeMakeContactWithBodyUsing contact: SCNPhysicsContact) -> Bool {
        return (contact.nodeA.physicsBody?.categoryBitMask == ContactCategory.snakeHead.rawValue
            && contact.nodeB.physicsBody?.categoryBitMask == ContactCategory.snake.rawValue)
            || (contact.nodeA.physicsBody?.categoryBitMask == ContactCategory.snake.rawValue
                && contact.nodeB.physicsBody?.categoryBitMask == ContactCategory.snakeHead.rawValue)
    }

    func handle(didSnakeMakeContactWithArenaUsing contact: SCNPhysicsContact) -> Bool {
        return contact.nodeA.physicsBody?.categoryBitMask == ContactCategory.arena.rawValue
            || contact.nodeB.physicsBody?.categoryBitMask == ContactCategory.arena.rawValue
    }
}

// MARK: - Utility

private extension GamePresenter {

    func makeStartGameTimer() -> Driver<Int> {
        let tickInterval = 1
        let resendAvailabilityTimeInterval = 3
        return Timer
            .publish(every: .init(tickInterval), on: .main, in: .default)
            .autoconnect()
            .map(to: tickInterval)
            .scan(resendAvailabilityTimeInterval) { $0 - $1 }
            .prepend(resendAvailabilityTimeInterval)
            .prefix(resendAvailabilityTimeInterval + 1)
            .asDriver()
    }
}
